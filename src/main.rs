use clap::{App, Arg};

fn main() {
    
    
    let matches = App::new("MyApp")
        .arg(
            Arg::with_name("version")
                .help("display version")
                .takes_value(false)
                .long("version")
                .short("v")
                .required(false)
        )
        .arg(
            Arg::with_name("port")
                .help("the port used for client-server interactions")
                .takes_value(true)
                .long("port")
                .short("p")
                .required(false)
                .default_value("5201")
        )
        .arg(
            Arg::with_name("format")
                .help("the format in which to deplay information (json, megabit/sec, megabyte/sec)")
                .takes_value(true)
                .long("format")
                .short("f")
                .required(false)
                .default_value("json")
                .possible_values(&["json", "bit", "byte"]),
        )
        .arg(
            Arg::with_name("interval")
                .help("the number of seconds to wait before producing periodic status reports; 0.0 to disable")
                .takes_value(true)
                .long("interval")
                .short("i")
                .required(false)
                .default_value("0.0")
        )
        .arg(
            Arg::with_name("interval")
                .help("the number of seconds to wait before producing periodic status reports; 0.0 to disable")
                .takes_value(true)
                .long("interval")
                .short("i")
                .required(false)
                .default_value("0.0")
        )
        .arg(
            Arg::with_name("file")
                .help("a file to use as either a data-source or buffer, depending on direction of traffic; if unspecified, transient data will be used instead")
                .takes_value(true)
                .long("file")
                .short("F")
                .required(false)
                .default_value("")
        )
        .arg(
            Arg::with_name("file")
                .help("a file to use as either a data-source or buffer, depending on direction of traffic; if unspecified, transient data will be used instead")
                .takes_value(true)
                .long("file")
                .short("F")
                .required(false)
                .default_value("")
        )
        .arg(
            Arg::with_name("affinity")
                .help("specify logical CPUs, delimited by commas, across which to round-robin affinity; not supported on all systems")
                .takes_value(true)
                .long("file")
                .short("A")
                .required(false)
                .multiple(true)
                .default_value("-1")
        )
        .arg(
            Arg::with_name("verbose")
                .help("provide more information with any non-JSON output")
                .takes_value(false)
                .long("verbose")
                .short("V")
                .required(false)
        )
        .arg(
            Arg::with_name("debug")
                .help("emit debug-level logging on stderr; default is info and above")
                .takes_value(false)
                .long("debug")
                .short("d")
                .required(false)
        )
        .arg(
            Arg::with_name("resolution")
                .help("the target resolution for calculations, in Hz")
                .takes_value(true)
                .long("resolution")
                .required(false)
                .default_value("0.125")
        )
        
        
        .arg(
            Arg::with_name("server")
                .help("run in server mode")
                .takes_value(false)
                .long("server")
                .short("s")
                .required(false)
                .conflicts_with("client")
        )
        .arg(
            Arg::with_name("buffertime")
                .help("the number of seconds to retain testing results, for clients that get disconnected before retrieval")
                .takes_value(true)
                .long("buffertime")
                .required(false)
                .default_value("60.0")
                .conflicts_with("client")
        )
        
        
        .arg(
            Arg::with_name("client")
                .help("run as a client to the specified server")
                .takes_value(true)
                .long("client")
                .short("c")
                .required(false)
                .default_value("")
                .conflicts_with("server")
        )
        .arg(
            Arg::with_name("udp")
                .help("use UDP rather than TCP")
                .takes_value(false)
                .long("udp")
                .short("u")
                .required(false)
                .conflicts_with("server")
        )
        .arg(
            Arg::with_name("bandwidth")
                .help("target bandwidth in bits/sec; this value is applied to each stream, with a default target of 1 megabit/second for all protocols (note: megabit, not mebibit, and unlike iperf3, data is evenly distributed by resolution, not frontloaded)")
                .takes_value(true)
                .long("bandwidth")
                .short("b")
                .required(false)
                .default_value("1000000")
                .conflicts_with("server")
        )
        .arg(
            Arg::with_name("time")
                .help("the time in seconds for which to transmit, as an alternative to bytes and block-count; time is used by default")
                .takes_value(true)
                .long("time")
                .short("t")
                .required(false)
                .default_value("10.0")
                .conflicts_with("server")
                .conflicts_with("bytes")
                .conflicts_with("blockcount")
        )
        .arg(
            Arg::with_name("omit")
                .help("omit a number of seconds from the start of calculations, in non-JSON modes, to avoid including TCP ramp-up in averages")
                .takes_value(true)
                .long("omit")
                .short("O")
                .default_value("0.0")
                .required(false)
        )
        .arg(
            Arg::with_name("bytes")
                .help("the number of bytes to transmit, as an alternative to time and block-count")
                .takes_value(true)
                .long("time")
                .short("t")
                .required(false)
                .default_value("0")
                .conflicts_with("server")
                .conflicts_with("time")
                .conflicts_with("blockcount")
        )
        .arg(
            Arg::with_name("blockcount")
                .help("the number of blocks (packets) to transmit, as an alternative to time and bytes")
                .takes_value(true)
                .long("blockcount")
                .short("k")
                .required(false)
                .default_value("0")
                .conflicts_with("server")
                .conflicts_with("time")
                .conflicts_with("bytes")
        )
        .arg(
            Arg::with_name("length")
                .help("length of the buffer to exchange; for TCP, this defaults to 128kilobytes; for UDP, it's based on MTU and IP family")
                .takes_value(true)
                .long("blockcount")
                .short("k")
                .required(false)
                .default_value("0")
                .conflicts_with("server")
                .conflicts_with("time")
                .conflicts_with("bytes")
        )
        .arg(
            Arg::with_name("cport")
                .help("bind the client data-stream to a specific port (default is to let the OS choose one)")
                .takes_value(true)
                .long("cport")
                .required(false)
                .default_value("0")
        )
        .arg(
            Arg::with_name("parallel")
                .help("the number of parallel data-streams to use")
                .takes_value(true)
                .long("parallel")
                .short("P")
                .required(false)
                .default_value("1")
        )
        .arg(
            Arg::with_name("reverse")
                .help("run in reverse-mode (server sends, client receives)")
                .takes_value(false)
                .long("reverse")
                .short("R")
                .required(false)
        )
        .arg(
            Arg::with_name("window")
                .help("window-size, in bytes, for TCP tests")
                .takes_value(false)
                .long("window")
                .short("w")
                .required(false)
        )
        .arg(
            Arg::with_name("mss")
                .help("maximum segment-size, for TCP tests (default is based on MTU)")
                .takes_value(false)
                .long("mss")
                .short("M")
                .required(false)
        )
        .arg(
            Arg::with_name("nodelay")
                .help("use no-dlay mode for TCP tests, deisabling Nagle's Algorithm")
                .takes_value(false)
                .long("no-delay")
                .short("N")
                .required(false)
        )
        .arg(
            Arg::with_name("congestion")
                .help("use a specific congestion-control algorithm for traffic-shaping")
                .takes_value(false)
                .long("congestion")
                .short("C")
                .required(false)
        )
        .arg(
            Arg::with_name("version4")
                .help("use IPv4, instead of the system default")
                .takes_value(false)
                .long("version4")
                .short("4")
                .required(false)
        )
        .arg(
            Arg::with_name("version6")
                .help("use IPv6, instead of the system default")
                .takes_value(false)
                .long("version6")
                .short("6")
                .required(false)
        )
        .arg(
            Arg::with_name("tos")
                .help("set the IP type-of-service flag")
                .takes_value(true)
                .long("tos")
                .short("S")
                .default_value("0")
                .required(false)
        )
        .arg(
            Arg::with_name("flowlabel")
                .help("set the IPv6 flow-label")
                .takes_value(true)
                .long("flowlabel")
                .short("L")
                .default_value("0")
                .required(false)
        )
        .arg(
            Arg::with_name("zerocopy")
                .help("use a zero-copy mode of sending data, like sendfile, to reduce transmission latency")
                .takes_value(false)
                .long("zerocopy")
                .short("Z")
                .required(false)
        )
    .get_matches();
    
    
    
}
