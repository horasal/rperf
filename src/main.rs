use clap::{App, Arg};

fn main() {
    
    
    let matches = App::new("MyApp")
        .arg(
            Arg::new("version")
                .about("display version")
                .takes_value(false)
                .long("version")
                .short("v")
                .required(false)
        )
        .arg(
            Arg::new("port")
                .about("the port used for client-server interactions")
                .takes_value(true)
                .long("port")
                .short("p")
                .required(false)
                .default(5201)
        )
        .arg(
            Arg::new("format")
                .about("the format in which to deplay information (json, megabit/sec, megabyte/sec)")
                .takes_value(true)
                .long("format")
                .short("f")
                .required(false)
                .default("json")
                .possible_values(&["json", "bit", "byte"]),
        )
        .arg(
            Arg::new("interval")
                .about("the number of seconds to wait before producing periodic status reports; 0.0 to disable")
                .takes_value(true)
                .long("interval")
                .short("i")
                .required(false)
                .default(0.0)
        )
        .arg(
            Arg::new("interval")
                .about("the number of seconds to wait before producing periodic status reports; 0.0 to disable")
                .takes_value(true)
                .long("interval")
                .short("i")
                .required(false)
                .default(0.0)
        )
        .arg(
            Arg::new("file")
                .about("a file to use as either a data-source or buffer, depending on direction of traffic; if unspecified, transient data will be used instead")
                .takes_value(true)
                .long("file")
                .short("F")
                .required(false)
                .default("")
        )
        .arg(
            Arg::new("file")
                .about("a file to use as either a data-source or buffer, depending on direction of traffic; if unspecified, transient data will be used instead")
                .takes_value(true)
                .long("file")
                .short("F")
                .required(false)
                .default("")
        )
        .arg(
            Arg::new("affinity")
                .about("specify logical CPUs, delimited by commas, across which to round-robin affinity; not supported on all systems")
                .takes_value(true)
                .long("file")
                .short("A")
                .required(false)
                .multiple(true)
                .default(-1)
        )
        .arg(
            Arg::new("verbose")
                .about("provide more information with any non-JSON output")
                .takes_value(false)
                .long("verbose")
                .short("V")
                .required(false)
        )
        .arg(
            Arg::new("debug")
                .about("emit debug-level logging on stderr; default is info and above")
                .takes_value(false)
                .long("debug")
                .short("d")
                .required(false)
        )
        .arg(
            Arg::new("resolution")
                .about("the target resolution for calculations, in Hz")
                .takes_value(true)
                .long("resolution")
                .required(false)
                .default(0.125)
        )
        
        
        .arg(
            Arg::new("server")
                .about("run in server mode")
                .takes_value(false)
                .long("server")
                .short("s")
                .required(false)
                .conflicts_with("client")
        )
        .arg(
            Arg::new("cachetime")
                .about("the number of seconds to retain testing results, for clients that get disconnected before retrieval")
                .takes_value(true)
                .long("cachetime")
                .required(false)
                .default(60.0)
                .conflicts_with("client")
        )
        
        
        .arg(
            Arg::new("client")
                .about("run as a client to the specified server")
                .takes_value(true)
                .long("client")
                .short("c")
                .required(false)
                .default("")
                .conflicts_with("server")
        )
        .arg(
            Arg::new("udp")
                .about("use UDP rather than TCP")
                .takes_value(false)
                .long("udp")
                .short("u")
                .required(false)
                .conflicts_with("server")
        )
        .arg(
            Arg::new("bandwidth")
                .about("target bandwidth in bits/sec; this value is applied to each stream, with a default target of 1 megabit/second for all protocols (note: megabit, not mebibit, and unlike iperf3, data is evenly distributed by resolution, not frontloaded)")
                .takes_value(true)
                .long("bandwidth")
                .short("b")
                .required(false)
                .default(1000000)
                .conflicts_with("server")
        )
        .arg(
            Arg::new("time")
                .about("the time in seconds for which to transmit, as an alternative to bytes and block-count; time is used by default")
                .takes_value(true)
                .long("time")
                .short("t")
                .required(false)
                .default(10.0)
                .conflicts_with("server")
                .conflicts_with("bytes")
                .conflicts_with("blockcount")
        )
        .arg(
            Arg::new("omit")
                .about("omit a number of seconds from the start of calculations, in non-JSON modes, to avoid including TCP ramp-up in averages")
                .takes_value(true)
                .long("omit")
                .short("O")
                .default(0.0)
                .required(false)
        )
        .arg(
            Arg::new("bytes")
                .about("the number of bytes to transmit, as an alternative to time and block-count")
                .takes_value(true)
                .long("time")
                .short("t")
                .required(false)
                .default(0)
                .conflicts_with("server")
                .conflicts_with("time")
                .conflicts_with("blockcount")
        )
        .arg(
            Arg::new("blockcount")
                .about("the number of blocks (packets) to transmit, as an alternative to time and bytes")
                .takes_value(true)
                .long("blockcount")
                .short("k")
                .required(false)
                .default(0)
                .conflicts_with("server")
                .conflicts_with("time")
                .conflicts_with("bytes")
        )
        .arg(
            Arg::new("length")
                .about("length of the buffer to exchange; for TCP, this defaults to 128kilobytes; for UDP, it's based on MTU and IP family")
                .takes_value(true)
                .long("blockcount")
                .short("k")
                .required(false)
                .default(0)
                .conflicts_with("server")
                .conflicts_with("time")
                .conflicts_with("bytes")
        )
        .arg(
            Arg::new("cport")
                .about("bind the client data-stream to a specific port (default is to let the OS choose one)")
                .takes_value(true)
                .long("cport")
                .required(false)
                .default(0)
        )
        .arg(
            Arg::new("parallel")
                .about("the number of parallel data-streams to use")
                .takes_value(true)
                .long("parallel")
                .short("P")
                .required(false)
                .default(1)
        )
        .arg(
            Arg::new("reverse")
                .about("run in reverse-mode (server sends, client receives)")
                .takes_value(false)
                .long("reverse")
                .short("R")
                .required(false)
        )
        .arg(
            Arg::new("window")
                .about("window-size, in bytes, for TCP tests")
                .takes_value(false)
                .long("window")
                .short("w")
                .required(false)
        )
        .arg(
            Arg::new("mss")
                .about("maximum segment-size, for TCP tests (default is based on MTU)")
                .takes_value(false)
                .long("mss")
                .short("M")
                .required(false)
        )
        .arg(
            Arg::new("nodelay")
                .about("use no-dlay mode for TCP tests, deisabling Nagle's Algorithm")
                .takes_value(false)
                .long("no-delay")
                .short("N")
                .required(false)
        )
        .arg(
            Arg::new("congestion")
                .about("use a specific congestion-control algorithm for traffic-shaping")
                .takes_value(false)
                .long("congestion")
                .short("C")
                .required(false)
        )
        .arg(
            Arg::new("version4")
                .about("use IPv4, instead of the system default")
                .takes_value(false)
                .long("version4")
                .short("4")
                .required(false)
        )
        .arg(
            Arg::new("version6")
                .about("use IPv6, instead of the system default")
                .takes_value(false)
                .long("version6")
                .short("6")
                .required(false)
        )
        .arg(
            Arg::new("tos")
                .about("set the IP type-of-service flag")
                .takes_value(true)
                .long("tos")
                .short("S")
                .default(0)
                .required(false)
        )
        .arg(
            Arg::new("flowlabel")
                .about("set the IPv6 flow-label")
                .takes_value(true)
                .long("flowlabel")
                .short("L")
                .default(0)
                .required(false)
        )
        .arg(
            Arg::new("zerocopy")
                .about("use a zero-copy mode of sending data, like sendfile, to reduce transmission latency")
                .takes_value(false)
                .long("zerocopy")
                .short("Z")
                .required(false)
        )
    .get_matches();
    
    
    
}
